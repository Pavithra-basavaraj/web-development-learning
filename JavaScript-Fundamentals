ðŸŸ¨ Formal Definition of JavaScript
JavaScript is a high-level, interpreted (or just-in-time compiled), dynamically typed, prototype-based, multi-paradigm programming language that conforms to the ECMAScript specification.
Letâ€™s break that definition down clearly:

ðŸ”¹ 1. High-Level Language
ï‚·You donâ€™t manage memory directly (like C or C++).
ï‚·JavaScript handles memory allocation and garbage collection automatically.
ï‚·Easier for humans to read and write.
ðŸ“˜ Example:
let x = 10; // You donâ€™t deal with addresses or pointers

ðŸ”¹ 2. Interpreted / Just-In-Time (JIT) Compiled
ï‚·JavaScript code is not precompiled into machine code before running.
ï‚·Instead, the browserâ€™s JavaScript engine (like V8 or SpiderMonkey) interprets and compiles it at runtime using JIT compilation, improving speed.

ðŸ”¹ 3. Dynamically Typed
ï‚·You donâ€™t declare variable types.
ï‚·The type of a variable is determined at runtime, and it can change.
ðŸ“˜ Example:
let data = 5;     // number
data = "Hello";   // now string âœ… allowed

ðŸ”¹ 4. Prototype-Based Object Orientation
ï‚·JavaScript uses prototypes instead of classical inheritance (like Java or C++).
ï‚·Every object can inherit properties and methods from another object (its prototype).
ðŸ“˜ Example:
let person = { greet() { console.log("Hi!"); } };
let student = Object.create(person);
student.greet(); // Inherits greet() from person

ðŸ”¹ 5. Multi-Paradigm
ï‚·JavaScript supports multiple programming styles:
oProcedural (traditional step-by-step)
oObject-Oriented (using objects and prototypes)
oFunctional (using higher-order functions, closures, etc.)
ðŸ“˜ Example:
// Functional
[1,2,3].map(x => x * 2);

// Object-oriented
class Car {
  start() { console.log("Car started"); }
}

ðŸ”¹ 6. Single-Threaded but Asynchronous
ï‚·JavaScript executes code in a single thread (one line at a time), but it can handle asynchronous tasks (like API calls or timers) using:
oEvent loop
oCallbacks
oPromises
oasync/await
ðŸ“˜ Example:
console.log("Start");
setTimeout(() => console.log("Async Task"), 1000);
console.log("End");
// Output: Start â†’ End â†’ Async Task

ðŸ”¹ 7. Conforms to ECMAScript
ï‚·JavaScript is based on the ECMAScript standard (ES) â€” a set of language rules defined by ECMA International.
ï‚·Modern versions: ES5, ES6 (2015), and beyond (ES2023, etc.)

ðŸ”¹ 8. Runs in Multiple Environments
ï‚·Originally designed for web browsers.
ï‚·Now also runs on servers using Node.js.

ðŸ§  In Short:
JavaScript is a lightweight, interpreted, dynamic, object-oriented scripting language, primarily used for client-side web development, but also widely used in server-side, mobile, and desktop applications.

ðŸ’¡ Key Characteristics Summary
Feature	Description
Type System	Dynamic, loosely typed
Compilation	Interpreted / JIT compiled
Paradigm	Multi-paradigm (functional, OOP, procedural)
Memory Management	Automatic (garbage collected)
Execution	Single-threaded, asynchronous
Specification	ECMAScript
Platform	Cross-platform (browser, Node.js, etc.)

ðŸŸ© Formal Definition of Java
Java is a high-level, class-based, object-oriented, general-purpose programming language that is platform-independent due to its use of the Java Virtual Machine (JVM).
It is compiled and interpreted, statically typed, and follows the â€œwrite once, run anywhereâ€ (WORA) principle.
Now letâ€™s break down that definition piece by piece ðŸ‘‡

ðŸ”¹ 1. High-Level Language
ï‚·Java is close to human language and hides hardware-level details like memory management or registers.
ï‚·It provides automatic garbage collection and built-in memory handling.
ðŸ“˜ Example:
int a = 10;  // You donâ€™t manage memory manually like in C

ðŸ”¹ 2. Class-Based and Object-Oriented
ï‚·Everything in Java revolves around classes and objects.
ï‚·Java follows OOP principles: Encapsulation, Inheritance, Polymorphism, and Abstraction.
ðŸ“˜ Example:
class Car {
    void start() { System.out.println("Car started"); }
}
âœ… Every piece of code (except primitives) exists inside a class.

ðŸ”¹ 3. General-Purpose Language
ï‚·Java is not limited to one domain â€” itâ€™s used for:
oWeb development
oMobile apps (Android)
oDesktop apps
oEnterprise software
oCloud and IoT systems

ðŸ”¹ 4. Platform Independent (via JVM)
ï‚·Java code is compiled into bytecode, not machine code.
ï‚·This bytecode runs on the Java Virtual Machine (JVM), which is available for all operating systems.
ðŸ“˜ Process:
Source Code (.java) â†’ Compiler â†’ Bytecode (.class) â†’ JVM â†’ Machine Code
âœ… This gives Java its famous property:
â€œWrite Once, Run Anywhere (WORA)â€

ðŸ”¹ 5. Compiled and Interpreted
ï‚·Java uses both compilation and interpretation:
1.The Java compiler (javac) converts source code into bytecode.
2.The JVM interpreter (Java Runtime) executes the bytecode line by line (or uses JIT â€“ Just-In-Time compilation for faster execution).

ðŸ”¹ 6. Statically Typed
ï‚·Every variableâ€™s data type must be declared at compile time.
ï‚·The compiler checks type consistency before execution, reducing runtime errors.
ðŸ“˜ Example:
int x = 10;
x = "Hello"; // âŒ Compile-time error

ðŸ”¹ 7. Strongly Typed
ï‚·Java does not allow implicit conversions between incompatible data types.
ï‚·You must use type casting explicitly.
ðŸ“˜ Example:
double d = 10.5;
int i = (int) d; // Explicit casting

ðŸ”¹ 8. Secure
ï‚·Java has no direct access to pointers (unlike C/C++).
ï‚·It runs code in a sandbox environment, especially in web applications.
ï‚·It provides exception handling and automatic garbage collection for safer execution.

ðŸ”¹ 9. Multithreaded
ï‚·Java supports concurrent execution of two or more parts of a program using threads.
ï‚·It allows better performance for CPU-intensive tasks.
ðŸ“˜ Example:
class MyThread extends Thread {
  public void run() { System.out.println("Thread running"); }
}

ðŸ”¹ 10. Robust and Reliable
ï‚·Java is designed to reduce common programming errors.
ï‚·It includes strong memory management, exception handling, and type checking.

ðŸ§  In Short:
Java is a platform-independent, object-oriented, statically typed, and secure programming language, designed for portability, performance, and reliability across different environments.

ðŸ’¡ Key Characteristics Summary
Feature	Description
Type System	Static & Strongly Typed
Compilation	Compiled â†’ Bytecode â†’ Interpreted by JVM
Paradigm	Object-Oriented (supports some functional features)
Memory Management	Automatic Garbage Collection
Execution	Multithreaded
Platform	Platform Independent (JVM)
Security	High (no pointers, sandboxed execution)
Developer Motto	â€œWrite Once, Run Anywhereâ€

ðŸŸ© 1. Data Types â€” Formal Definition
A data type defines the type of data that a variable can hold, and it determines the size, memory location, and the operations that can be performed on that data.
In short:
ï‚·Data types tell the compiler or interpreter how to interpret and store data in memory.
ï‚·They ensure type safety â€” you canâ€™t assign or operate incompatible values (like adding a string to an integer in Java).

ðŸŸ¢ 2. Data Types in Java
Java is a statically typed, compiled language â€” meaning every variableâ€™s type must be declared at compile time.
ðŸ”¸ Categories:
1.Primitive Data Types
2.Non-Primitive (Reference) Data Types

ðŸ§© Primitive Data Types
These are predefined by Java and stored directly in stack memory.
Type	Size	Example	Description
byte	1 byte	byte a = 10;	Small integers (-128 to 127)
short	2 bytes	short s = 1000;	Larger integers
int	4 bytes	int x = 100;	Default integer type
long	8 bytes	long l = 123456789L;	Very large integers
float	4 bytes	float f = 12.3f;	Decimal (single precision)
double	8 bytes	double d = 12.3456;	Decimal (double precision)
char	2 bytes	char c = 'A';	Single 16-bit Unicode character
boolean	1 bit (logical)	boolean b = true;	True or false
âœ… Key point: Primitive variables store values directly (not references).

ðŸ§± Non-Primitive (Reference) Data Types
These are created by the programmer and store references to objects in heap memory.
Examples:
ï‚·String
ï‚·Arrays
ï‚·Classes & Interfaces
ï‚·Collections (e.g. ArrayList, HashMap, etc.)
ðŸ“˜ Example:
String name = "Pavitra";
int[] marks = {85, 90, 92};
âœ… name and marks hold references (addresses) to objects in heap memory.

ðŸ§  Important Topics in Java Data Types
1.Type Casting
oConverting one data type to another.
oImplicit casting (widening): automatic
oint x = 10;
odouble y = x; // int â†’ double
oExplicit casting (narrowing): manual
odouble a = 10.5;
oint b = (int) a; // double â†’ int
2.Wrapper Classes
oConverts primitives into objects (int â†’ Integer, double â†’ Double).
oUseful in Collections and Generics.
3.Autoboxing / Unboxing
oAutoboxing: Primitive â†’ Wrapper
Integer num = 5;
oUnboxing: Wrapper â†’ Primitive
int n = num;
4.Default Values
oint = 0, boolean = false, String = null (for instance variables).

ðŸŸ¨ 3. Data Types in JavaScript
JavaScript is dynamically typed â€” meaning you donâ€™t declare the type of variable; itâ€™s decided at runtime.
let a = 10;        // number
a = "Hello";       // now string âœ… allowed

ðŸ”¹ Primitive Data Types (7 total)
Type	Example	Description
Number	let x = 10;	Includes integers and floats
String	let s = "Hi";	Text data
Boolean	let flag = true;	True or false
Undefined	let y;	Variable declared but not assigned
Null	let z = null;	Intentional empty value
Symbol	let sym = Symbol("id");	Unique and immutable identifier
BigInt	let big = 123n;	For large integers beyond 2^53-1
âœ… All primitives are immutable (you canâ€™t change the actual value â€” only reassign).

ðŸ”¹ Non-Primitive (Reference) Data Types
Type	Example	Description
Object	{name: "Pavitra", age: 21}	Collection of key-value pairs
Array	[1, 2, 3]	Ordered list
Function	function greet(){}	Reusable block of code
âœ… These are mutable and stored in heap memory, while references are stored in stack memory.

ðŸ§  Important Topics in JavaScript Data Types
1.Type Coercion
oJS automatically converts types when needed.
2.console.log('5' + 2); // "52" (string concatenation)
3.console.log('5' - 2); // 3   (numeric conversion)
4.typeof Operator
oReturns the type of a variable.
5.typeof 10;      // "number"
6.typeof "Hi";    // "string"
7.typeof null;    // "object" (special JS quirk)
8.Type Conversion
oExplicit conversions:
oNumber("123");  // 123
oString(123);    // "123"
oBoolean(0);     // false
9.Pass by Value vs Reference
oPrimitives â†’ passed by value
oObjects/Arrays â†’ passed by reference

âš–ï¸ Comparison Summary
Feature	Java	JavaScript
Typing	Static	Dynamic
Memory	Stack (primitives), Heap (objects)	Stack (reference), Heap (objects)
Mutability	Primitives immutable, objects mutable	Primitives immutable, objects mutable
Casting	Explicit/Implicit	Automatic (type coercion)
Total Primitives	8	7
hoisting in JavaScript
What is hoisting in JavaScript? (Formal, interview-ready)
Short definition (1â€“2 lines):
Hoisting is the JavaScript behavior where declarations (variable and function declarations) are conceptually moved to the top of their containing scope before code execution. Initialization/assignment is not hoisted â€” only the declaration.
Interview-y answer: â€œHoisting is the mechanism by which JS moves declarations to the top of their scope at compile time â€” so declarations are known before execution; however initializations stay in place.â€

How it actually works (step-by-step)
JS engines do two phases before running your code:
1.Creation (compile) phase â€” the engine scans the scope and registers declarations:
ofunction declarations are created and fully initialized (the function object is available).
ovar variable declarations are created and initialized to undefined.
olet and const declarations are registered but not initialized (they are in the Temporal Dead Zone until their line is evaluated).
oFunction expressions and arrow functions assigned to variables behave like normal assignments â€” the variable declaration may be hoisted (for var â†’ undefined, for let/const â†’ TDZ), but the function value is not available until assignment.
2.Execution phase â€” code runs line-by-line; initializations and assignments happen now.
3.Behavior by declaration type (with examples)
a)var
console.log(a); // undefined
var a = 10;
console.log(a); // 10
Why: var a is hoisted and initialized to undefined during the compile phase. The assignment = 10 happens at runtime.

3.let and const (TDZ â€” Temporal Dead Zone)

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;
Why: let/const are hoisted in the sense they are known to the engine, but they are uninitialized until execution reaches the declaration line. Access before initialization throws a ReferenceError. This period is the TDZ.
const must also be initialized at declaration; otherwise it's a syntax error.

3. Function declarations
   greet();             // "hi"
   function greet() { console.log("hi"); }
Why: Function declarations are hoisted and fully initialized â€” you can call them before their declaration in the file/scope.

4. Function expressions / arrow functions assigned to var, let, const
foo();               // TypeError: foo is not a function
var foo = function() { console.log("hi"); };
bar();               // ReferenceError: Cannot access 'bar' before initialization
let bar = () => {};

ðŸ§  First â€” Understand: JS runs in two phases
Every time you run JavaScript code (in browser or Node.js), the JS engine (like Chromeâ€™s V8) does two things:
1.Creation Phase (also called Compile Phase)
oThe engine scans your code before running it.
oIt â€œsets upâ€ the variables and functions in memory.
oNo actual code is executed yet.
2.Execution Phase (Runtime)
oThe code now runs line by line, from top to bottom.
oAssignments and operations happen during this phase.

Letâ€™s take an example ðŸ‘‡
Example:
console.log(a);
var a = 10;

console.log(b);
let b = 20;

sayHi();
function sayHi() {
  console.log("Hello!");
}

ðŸ”¹ Phase 1: Creation (Compile phase)
The engine scans through the code and registers all declarations before running it.
Hereâ€™s what it does behind the scenes:
Declaration Type	What happens during creation phase
var a	Memory is created for a, and it is initialized to undefined
let b	Memory is created for b, but not initialized yet â†’ itâ€™s in the Temporal Dead Zone (TDZ)
function sayHi()	The entire function is created and stored in memory (you can call it anywhere in this scope)
So now, memory looks like this:
Memory setup after creation phase:
a â†’ undefined
b â†’ (uninitialized, TDZ)
sayHi â†’ [Function code]
âš ï¸ Nothing has executed yet â€” this is just setup.

ðŸ”¹ Phase 2: Execution (line by line)
Now, the JS engine starts running the code line by line:
Line 1:
console.log(a);
âœ… Variable a exists (from the creation phase) and is undefined,
so output:
undefined

Line 2:
var a = 10;
âž¡ï¸ This assigns the value 10 to a.
Now memory looks like:
a â†’ 10

Line 3:
console.log(b);
ðŸš« b exists, but itâ€™s still in the Temporal Dead Zone (TDZ) â€” it was declared with let but not yet initialized.
Trying to access it here causes:
ReferenceError: Cannot access 'b' before initialization

Line 4:
let b = 20;
âœ… Now b is initialized with value 20.
Memory now:
a â†’ 10
b â†’ 20

Line 5:
sayHi();
âœ… Function sayHi was fully created in the creation phase, so you can call it now even though it appears later in code.
Output:
Hello!

âœ… Final outputs:
undefined
ReferenceError
Hello!
ðŸŸ¨ 1. What is NaN (Not-a-Number)?
ðŸ”¹ Formal Definition
NaN stands for "Not a Number", and itâ€™s a special value in JavaScript that represents something that is not a valid numeric value, even though it is of type number.
Itâ€™s part of the Number type and is produced when a mathematical operation fails to return a valid number.

ðŸ”¹ Example 1: Invalid mathematical operation
let x = "hello" / 5;
console.log(x); // NaN
Here, JavaScript tries to divide a string ("hello") by a number (5), which makes no sense mathematically â†’ result is NaN.

ðŸ”¹ Example 2: Using Number conversion
Number("abc"); // NaN
"abc" canâ€™t be converted to a number.

ðŸ”¹ Key Points about NaN
1.Type of NaN is â€œnumberâ€
2.console.log(typeof NaN); // "number"
3.NaN is not equal to anything, not even itself
4.console.log(NaN === NaN); // false
âœ… Reason: NaN is used to represent invalid numbers, so comparing two invalid numbers doesnâ€™t make sense.
5.To check for NaN, use special functions
oGlobal function:
oisNaN(value)
Example:
isNaN("abc"); // true
isNaN(123);   // false
oBetter one:
oNumber.isNaN(value)
âœ… Safer because it doesnâ€™t convert non-numbers before checking.
Number.isNaN("abc"); // false
Number.isNaN(NaN);   // true

ðŸ”¹ When do we get NaN?
Case	Example	Output
Invalid arithmetic	"abc" / 2	NaN
Invalid number conversion	Number("xyz")	NaN
Math function with invalid input	Math.sqrt(-1)	NaN
Subtracting non-numeric strings	"a" - "b"	NaN

ðŸ§  In short:
NaN represents an invalid numeric result.
Itâ€™s a value of type number, but it means â€œnot a real numberâ€.

ðŸŸ¦ 2. What is typeof in JavaScript?
ðŸ”¹ Formal Definition
typeof is a unary operator in JavaScript that returns a string indicating the type of the operand (the kind of data stored in a variable).

ðŸ”¹ Syntax
typeof operand
or
typeof(operand)
(both work the same)

ðŸ”¹ Examples
typeof 10;          // "number"
typeof "Hello";     // "string"
typeof true;        // "boolean"
typeof undefined;   // "undefined"
typeof null;        // "object"    âŒ (historical bug)
typeof [1, 2, 3];   // "object"
typeof {a:1};       // "object"
typeof function(){} // "function"
ðŸŸ¨ What is a Ternary Operator in JavaScript?
ðŸ”¹ Formal Definition
The ternary operator (? :) is a conditional operator in JavaScript that evaluates a condition and returns one of two values â€” one if the condition is true, and another if it is false.
Itâ€™s called ternary because it takes three operands:
1.A condition to evaluate
2.The result if the condition is true
3.The result if the condition is false

ðŸ”¹ Syntax
condition ? expressionIfTrue : expressionIfFalse;

ðŸ”¹ Simple Example
let age = 20;
let result = (age >= 18) ? "Adult" : "Minor";
console.log(result); // "Adult"
âœ… Explanation:
ï‚·Condition â†’ age >= 18
ï‚·If true â†’ "Adult"
ï‚·If false â†’ "Minor"

ðŸ”¹ How It Works
Itâ€™s basically a short form of if...else statement.
Using if...else:
if (age >= 18) {
  result = "Adult";
} else {
  result = "Minor";
}
Using ternary operator:
result = (age >= 18) ? "Adult" : "Minor";
âœ… Same logic, but shorter and cleaner.

ðŸ”¹ Example 2 â€” Number check
let num = -5;
let message = (num > 0) ? "Positive" : "Negative or Zero";
console.log(message); // "Negative or Zero"

ðŸ”¹ Example 3 â€” Nested ternary operator
You can use multiple conditions (but carefully for readability).
let marks = 85;
let grade = (marks >= 90) ? "A+" :
             (marks >= 75) ? "A" :
             (marks >= 60) ? "B" : "C";

console.log(grade); // "A"
âœ… Explanation:
ï‚·First condition true? â†’ "A+"
ï‚·If not, check next condition â†’ "A"
ï‚·Else check next â†’ "B"
ï‚·Otherwise â†’ "C"

ðŸ”¹ Example 4 â€” Assign values directly
let isLoggedIn = true;
let buttonText = isLoggedIn ? "Logout" : "Login";
console.log(buttonText); // "Logout"

ðŸ§  Key Points to Remember
Feature	Description
Operator symbol	? :
Operands	3 (condition, true-expression, false-expression)
Returns	A value, not just executes a statement
Used for	Short, inline decisions
Avoid	Overusing nested ternaries (makes code hard to read)

ðŸ’¡ Interview Tips
1.Q: Why is it called a â€œternaryâ€ operator?
A: Because it takes three operands (unlike binary operators like + or unary like !).
2.Q: Can we use ternary operator inside another ternary?
A: Yes, but keep it simple for readability.
3.Q: What does the ternary operator return?
A: It returns the value of the executed expression, not just runs code.
4.Q: Is it same as if-else?
A: Functionally yes, but ternary operator is used for expressions, while if-else is a control statement.
5.ðŸ§© Example of difference (Expression vs Statement)
// if-else is a statement
if (x > 10) {
  console.log("Big");
} else {
  console.log("Small");
      }
// ternary is an expression (it returns a value)
console.log(x > 10 ? "Big" : "Small");

6.Nested ternary operator
You can use multiple conditions (but carefully for readability).
     let marks = 85;
    let grade = (marks >= 90) ? "A+" :
   (marks >= 75) ? "A" :
   (marks >= 60) ? "B" : "C";
console.log(grade); // "A"
